"""
Library for generating and managing copy-and-paste confirmation messages.
"""

import base64
import datetime
import getpass
import hashlib
import json
import pathlib
import platform
import sys
import uuid
from typing import Any

import nacl.encoding
import nacl.exceptions
import nacl.secret


class JsonBoxFile:
    """
    A simple way to have encrypted persistence.
    """

    def __init__(self, key: str, filename: str | pathlib.Path | None):
        """Setup the box."""
        self._box = nacl.secret.SecretBox(
            hashlib.blake2b(
                key.encode("utf-8"), digest_size=nacl.secret.SecretBox.KEY_SIZE
            ).digest()
        )

        self._path = filename
        self.load()

    def store(self):
        """Store the current state."""
        self._data["user"] = getpass.getuser()
        self._data["host"] = platform.node()
        self._data["cmd"] = sys.executable
        self._data["date"] = round(
            datetime.datetime.now(datetime.timezone.utc).timestamp()
        )

        # Filter out keys that start with _
        to_store = {}
        for key, value in self._data.items():
            if not key.startswith("_"):
                to_store[key] = value

        if self._path is not None:
            with open(self._path, "w") as fh:
                fh.write(
                    self._box.encrypt(
                        json.dumps(to_store).encode("utf-8"),
                        encoder=nacl.encoding.URLSafeBase64Encoder,
                    ).decode("utf-8")
                )

    def load(self):
        self._data = {}
        if self._path is not None:
            try:
                with open(self._path, "rb") as fh:
                    self._data: dict[str, Any] = json.loads(
                        self._box.decrypt(
                            fh.read(),
                            encoder=nacl.encoding.URLSafeBase64Encoder,
                        )
                    )
                    assert isinstance(self._data, dict)
            except (nacl.exceptions.CryptoError, OSError, AssertionError):
                self._data = {}

    def __getitem__(self, key: Any) -> Any:
        return self._data[key]

    def __setitem__(self, key: Any, value: Any):
        self._data[key] = value
        self.store()

    def __contains__(self, key):
        return key in self._data

    def get(
        self, key: Any, default: Any = None, *, store: bool = False
    ) -> Any:
        if key in self._data:
            return self._data[key]
        else:
            if store:
                self._data[key] = default
            return default


class ConfirmationCode:
    """
    Access to secret codes and data files.
    """

    def __init__(self, key: str):
        self.key = hashlib.blake2b(
            key.encode("utf-8"), digest_size=nacl.secret.SecretBox.KEY_SIZE
        ).digest()

    def confirmation(self, data: dict) -> str:
        """
        Generate a b64 encoded JSON object with an embedded authentication hash.
        """
        data = data.copy()
        data["user"] = getpass.getuser()
        data["host"] = platform.node()
        data["cmd"] = sys.executable
        data["date"] = round(
            datetime.datetime.now(datetime.timezone.utc).timestamp()
        )
        raw = json.dumps(data, separators=(",", ":")).encode("utf-8")
        h = hashlib.blake2b(raw, digest_size=8, key=self.key)
        return base64.b64encode(h.digest() + raw).decode("utf-8")

    def validate(self, cfm: str) -> dict:
        """
        Validate a confirmation number generated by `generate`.

        Returns the dictionary object with the date nicely converted. Raises an
        exception if there was a validation error.
        """

        raw = base64.b64decode(cfm, validate=True)
        assert len(raw) > 8, "Missing digest."
        ah = hashlib.blake2b(raw[8:], digest_size=8, key=self.key).digest()
        assert ah == raw[0:8], "Invalid digest."
        data = json.loads(raw[8:])
        data["date"] = datetime.datetime.fromtimestamp(data["date"]).strftime(
            "%a %b %d, %Y %I:%M %p"
        )
        return data


def cli(subparsers):
    secrets_parser = subparsers.add_parser(
        "secrets", help="Decode secrets from STDIN."
    )

    secrets_parser.add_argument(
        "-k",
        "--key",
        type=str,
        required=False,
        default=str(uuid.getnode()),
        help="The key used for operations.",
    )
    secrets_parser.add_argument(
        "-f", "--file", type=str, help="The encrypted file to read."
    )
    secrets_parser.set_defaults(func=main)


def main(args):
    """
    Decode confirmation numbers from stdin.
    """

    vault = ConfirmationCode(key=args.key)

    Bold = "\x1b[1m"
    Reset = "\x1b[0m"
    F_LightGreen = "\x1b[92m"
    F_LightRed = "\x1b[91m"
    F_Default = "\x1b[39m"
    B_Default = "\x1b[49m"
    B_Black = "\x1b[40m"

    if args.file is None:
        while True:
            line = None
            got = ""
            while line != ".":
                line = input("> ")
                got += line.strip()
            got = got.replace("\n", "")
            got = got.replace(" ", "")
            got = got.replace("\t", "")
            for i in range(len(got)):
                for j in range(i + 1, len(got)):
                    try:
                        data = vault.validate(got[i : j + 1])
                        print("\n")
                        print(Bold, F_LightGreen, B_Black, sep="", end="")
                        print(data)
                        print(B_Default, F_Default, Reset, sep="", end="")
                        print("\n")
                    except Exception:
                        pass
    else:
        print(JsonBoxFile(key=args.key, filename=args.file)._data)
