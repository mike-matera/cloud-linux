"""
Library for generating and managing copy-and-paste confirmation messages.
"""

import base64
import datetime
import getpass
import hashlib
import importlib.resources
import json
import pathlib
import pickle
import platform
import sys
from typing import Any

import nacl.encoding
import nacl.exceptions
import nacl.secret


def has_embedded_key():
    return importlib.resources.files("kroz").joinpath("key.txt").is_file()


def embedded_key():
    return (
        importlib.resources.files("kroz")
        .joinpath("key.txt")
        .read_text(encoding="utf-8")
        .strip()
    )


class EncryptedStateFile:
    """
    A simple way to have encrypted persistence.
    """

    def __init__(self, key: str, filename: str | pathlib.Path | None):
        """Setup the box."""
        self._box = nacl.secret.SecretBox(
            hashlib.blake2b(
                key.encode("utf-8"), digest_size=nacl.secret.SecretBox.KEY_SIZE
            ).digest()
        )

        self._path = filename
        self.load()

    def store(self):
        """Store the current state."""
        self._data["user"] = getpass.getuser()
        self._data["host"] = platform.node()
        self._data["cmd"] = sys.executable
        self._data["date"] = round(
            datetime.datetime.now(datetime.timezone.utc).timestamp()
        )

        # Filter out keys that start with _
        to_store = {}
        for key, value in self._data.items():
            if not key.startswith("_"):
                to_store[key] = value

        if self._path is not None:
            with open(self._path, "w") as fh:
                fh.write(
                    self._box.encrypt(
                        pickle.dumps(to_store),
                        encoder=nacl.encoding.URLSafeBase64Encoder,
                    ).decode("utf-8")
                )

    def load(self):
        self._data = {}
        if self._path is not None:
            try:
                with open(self._path, "rb") as fh:
                    self._data: dict[str, Any] = pickle.loads(
                        self._box.decrypt(
                            fh.read(),
                            encoder=nacl.encoding.URLSafeBase64Encoder,
                        )
                    )
                    assert isinstance(self._data, dict)
            except (
                nacl.exceptions.CryptoError,
                OSError,
                AssertionError,
                pickle.UnpicklingError,
                # ValueError,
            ):
                self._data = {}

    def __getitem__(self, key: str) -> Any:
        return self._data[key]

    def __setitem__(self, key: str, value: Any):
        self._data[key] = value
        self.store()

    def __delitem__(self, key: str):
        del self._data[key]
        self.store()

    def __contains__(self, key):
        return key in self._data

    def get(
        self, key: Any, default: Any = None, *, store: bool = False
    ) -> Any:
        if key in self._data:
            return self._data[key]
        else:
            if store:
                self._data[key] = default
                self.store()
            return default


class ConfirmationCode:
    """
    Access to secret codes and data files.
    """

    def __init__(self, key: str):
        self.key = hashlib.blake2b(
            key.encode("utf-8"), digest_size=nacl.secret.SecretBox.KEY_SIZE
        ).digest()

    def confirmation(self, data: dict) -> str:
        """
        Generate a b64 encoded JSON object with an embedded authentication hash.
        """
        data = data.copy()
        data["user"] = getpass.getuser()
        data["host"] = platform.node()
        data["date"] = round(
            datetime.datetime.now(datetime.timezone.utc).timestamp()
        )
        raw = json.dumps(data, separators=(",", ":")).encode("utf-8")
        h = hashlib.blake2b(raw, digest_size=8, key=self.key)
        return base64.b64encode(h.digest() + raw).decode("utf-8")

    def validate(self, cfm: str) -> dict:
        """
        Validate a confirmation number generated by `generate`.

        Returns the dictionary object with the date nicely converted. Raises an
        exception if there was a validation error.
        """

        raw = base64.b64decode(cfm, validate=True)
        assert len(raw) > 8, "Missing digest."
        ah = hashlib.blake2b(raw[8:], digest_size=8, key=self.key).digest()
        assert ah == raw[0:8], "Invalid digest."
        data = json.loads(raw[8:])
        data["date"] = datetime.datetime.fromtimestamp(data["date"]).strftime(
            "%a %b %d, %Y %I:%M %p"
        )
        return data
