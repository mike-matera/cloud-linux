"""
Library for generating and managing copy-and-paste confirmation messages.
"""

import base64
import hashlib
import platform
import getpass
import json
import datetime
import uuid
import nacl.secret
import nacl.exceptions
import nacl.encoding
import pathlib
import sys

from typing import Any


class JsonBoxFile:
    """
    A simple way to have encrypted persistence.
    """

    def __init__(self, key: str, filename: str | pathlib.Path):
        """Setup the box."""
        self._box = nacl.secret.SecretBox(
            hashlib.blake2b(
                key.encode("utf-8"), digest_size=nacl.secret.SecretBox.KEY_SIZE
            ).digest()
        )
        self._path = pathlib.Path(filename)
        self.load()

    def store(self):
        """Store the current state."""
        self._data["user"] = getpass.getuser()
        self._data["host"] = platform.node()
        self._data["cmd"] = sys.executable
        self._data["date"] = round(
            datetime.datetime.now(datetime.timezone.utc).timestamp()
        )
        with open(self._path, "w") as fh:
            fh.write(
                self._box.encrypt(
                    json.dumps(self._data).encode("utf-8"),
                    encoder=nacl.encoding.URLSafeBase64Encoder,
                ).decode("utf-8")
            )

    def load(self):
        try:
            with open(self._path, "rb") as fh:
                self._data = json.loads(
                    self._box.decrypt(
                        fh.read(), encoder=nacl.encoding.URLSafeBase64Encoder
                    )
                )
        except (nacl.exceptions.CryptoError, OSError):
            self._data = {}

    def __getitem__(self, key: Any) -> Any:
        return self._data[key]

    def __setitem__(self, key: Any, value: Any):
        self._data[key] = value
        self.store()

    def __contains__(self, key):
        return key in self._data

    def get(self, key: Any, default: Any = None) -> Any:
        return self._data.get(key, default)


class ConfirmationCode:
    """
    Access to secret codes and data files.
    """

    def __init__(self, key: str):
        self.key = hashlib.blake2b(
            key.encode("utf-8"), digest_size=nacl.secret.SecretBox.KEY_SIZE
        ).digest()

    def confirmation(self, data: dict) -> str:
        """
        Generate a b64 encoded JSON object with an embedded authentication hash.
        """
        data = data.copy()
        data["user"] = getpass.getuser()
        data["host"] = platform.node()
        data["cmd"] = sys.executable
        data["date"] = round(
            datetime.datetime.now(datetime.timezone.utc).timestamp()
        )
        raw = json.dumps(data, separators=(",", ":")).encode("utf-8")
        h = hashlib.blake2b(raw, digest_size=8, key=self.key)
        return base64.b64encode(h.digest() + raw).decode("utf-8")

    def validate(self, cfm: str) -> dict:
        """
        Validate a confirmation number generated by `generate`.

        Returns the dictionary object with the date nicely converted. Raises an
        exception if there was a validation error.
        """

        raw = base64.b64decode(cfm, validate=True)
        assert len(raw) > 8
        ah = hashlib.blake2b(raw[8:], digest_size=8, key=self.key).digest()
        assert ah == raw[0:8]
        data = json.loads(raw[8:])
        data["date"] = datetime.datetime.fromtimestamp(data["date"]).strftime(
            "%a %b %d, %Y %I:%M %p"
        )
        return data


def cli(subparsers):
    secrets_parser = subparsers.add_parser(
        "secrets", help="Decode secrets from STDIN."
    )

    secrets_parser.add_argument(
        "-k",
        "--key",
        type=str,
        required=False,
        default=str(uuid.getnode()),
        help="The key used for operations.",
    )
    secrets_parser.add_argument(
        "-f", "--file", type=str, help="The encrypted file to read."
    )
    secrets_parser.set_defaults(func=main)


def main(args):
    """
    Decode confirmation numbers from stdin.
    """

    vault = ConfirmationCode(key=args.key)

    Bold = "\x1b[1m"
    Reset = "\x1b[0m"
    F_LightGreen = "\x1b[92m"
    F_LightRed = "\x1b[91m"
    F_Default = "\x1b[39m"
    B_Default = "\x1b[49m"
    B_Black = "\x1b[40m"

    if args.file is None:
        while True:
            line = None
            got = ""
            while line != ".":
                line = input("> ")
                got += line.strip()
            got = got.replace("\n", "")
            got = got.replace(" ", "")
            got = got.replace("\t", "")
            for i in range(len(got)):
                for j in range(i + 1, len(got)):
                    try:
                        data = vault.validate(got[i : j + 1])
                        print("\n")
                        print(Bold, F_LightGreen, B_Black, sep="", end="")
                        print(data)
                        print(B_Default, F_Default, Reset, sep="", end="")
                        print("\n")
                    except Exception:
                        pass
    else:
        print(JsonBoxFile(key=args.key, filename=args.file)._data)
